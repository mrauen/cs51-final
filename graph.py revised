# Graph.py
# Contains type definitions for graph and nodes, and methods for traversing, updating, and deleting. 
# Also contains brand graph and item graph.

import helpers
import pathfinder

# prediction_list: a list of (user ID, number of edges in path, prediction)
# items in prediction_list have not been rated
class Ratings:
  def __init__ (self, prediction_list = {}, tot_rated = 0, successes = 0):
    self.prediction_list = prediction_list
  	self.tot_rated = tot_rated
  	self.successes = successes
  	
class Edge:
  def __init__ (self, name = "", neighbor_pointer = None, diff_mean = 0, stdev = 0, num_ratings = 0, conf = 0, ratings = Ratings):
	self.name = name
	self.neighbor_pointer = neighbor_pointer
	self.diff_mean = diff_mean
	self.stdev = stdev
	self.num_ratings = num_ratings
	self.conf = conf
	self.ratings = ratings
	self.scaling_factor = scaling_factor #for brands, not accessed in item

class Item:
	def __init__ (self, id = -1, brand = "", nom_size = 0, act_size = 0,
		edge_list = {} ) : # this is where Edge() would go
	self.id = id
	self.brand = brand
	self.nom_size = nom_size
	self.act_size = act_size

class Brand:
	def __init__ (self, id = -1, brand = "", nom_size = 0, act_size = 0,
		edge_list = {}, item_list = {} ) : # this is where Edge() would go
	self.id = id

class Graph:
	def __init__ (self, name = "", item_list = {}): # this is where Item() would go
		self.name = name
		self.item_list = item_list
		self.itemid_list = [x[1] for x in self.item_list]
	def empty_graph (self):
		self.item_list = {}
	# check if item is in graph	
	def in_graph (self, item):
		for node in self.item_list 
			if node.id == item.id: 
				return True
		else return False

	def insert (self, item, userid):
		if item.id = -1:
			Helpers.new_item (self, item)
			# and add to edge_list that item all the edges pointing to user's items
			# and update all of user's items to have an edge pointing to new item
		else:
			# and add to edge_list that item all the edges pointing to user's items
			# and update all of user's items to have an edge pointing to new item
				


	def findpath (G, start, end):
		pathfinder(G, start, end) # defined in Pathfinder

	def predictor (path)	# path comes from another module where Dijkstra's or the fip heap is done
		# (Sigma diff_mean*num_ratings) / Sigma num_ratings

	def edge_update (self, edge)
		update # defined in helpers
